// Code generated by hertz generator.

package ws

import (
	"context"
	"github.com/bytedance/sonic"
	"github.com/cloudwego/hertz/pkg/app"
	"github.com/hertz-contrib/websocket"
	"hertz/demo/biz/dal/log"
	"hertz/demo/biz/handler/internal"
	"hertz/demo/pkg/response"
	"hertz/demo/pkg/utils"
	"time"
)

const (
	writeWait      = 10 * time.Second    // Time allowed to write a message to the peer.
	pongWait       = 60 * time.Second    // Time allowed to read the next pong message from the peer.
	pingPeriod     = (pongWait * 9) / 10 // Send pings to peer with this period. Must be less than pongWait.
	maxMessageSize = 1024                // Maximum message size allowed from peer.

	MsgTypeUser = "user" // 好友消息
	MsgTypeRoom = "room" //	群消息
)

var (
	a        internal.Api
	sender   WebSocketConnection
	newline  = []byte{'\n'}
	space    = []byte{' '}
	upgrader = websocket.HertzUpgrader{
		ReadBufferSize:  1024,
		WriteBufferSize: 1024,
		CheckOrigin: func(c *app.RequestContext) bool {
			return true
		},
	}
)

// ChatRoom .
// @Description	websocket 聊天api
// @Tags		ws
// @Success		200
// @router		/v1/hertz/ws [GET]
func ChatRoom(_ context.Context, c *app.RequestContext) {
	if err := a.SetReqWithSub(c).Error; err != nil {
		response.ErrorRequest(c, err)
		return
	}

	if err := upgrader.Upgrade(c, WebsocketHandler(*a.Sub)); err != nil {
		response.ErrorUnknown(c, err, "websocket upgrade err")
		return
	}
	response.Success(c)
}

// WebsocketHandler websocket客户端连接处理
func WebsocketHandler(sub int64) websocket.HertzHandler {
	return func(conn *websocket.Conn) {
		defer utils.LogFuncErr(conn.Close)
		conn.SetReadLimit(maxMessageSize)
		_ = conn.SetReadDeadline(time.Now().Add(pongWait))
		conn.SetPongHandler(func(string) error { return conn.SetReadDeadline(time.Now().Add(pongWait)) })

		sender.Connection.Set(sub, conn) // 用户上线
		defer func() {
			sender.Connection.Delete(sub) // 用户下线
			if err := conn.Close(); err != nil {
				log.Error().Msgf("close websocket conn err: %s", err.Error())
			}
		}()

		for {
			_, message, err := conn.ReadMessage() // 获取客户端发送的消息
			if err != nil {
				if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
					log.Error().Msg("" + err.Error())
				}
				break
			}
			var msg Message
			if err = sonic.Unmarshal(message, &msg); err != nil {
				log.Error().Msg("unmarshal message err" + err.Error())
				continue
			}

			switch msg.Type {
			case MsgTypeUser:
				if err = sender.SendUserMessage(sub, msg.ReceiveID, 0, &msg); err != nil {
					log.Error().Msgf("send user message err: %s", err.Error())
				}
			case MsgTypeRoom:
				if err = sender.SendRoomMessage(sub, msg.ReceiveID, &msg); err != nil {
					log.Error().Msgf("send room message err: %s", err.Error())
				}
			default:
				log.Error().Msg("msg type unknown")
			}
		}
	}
}
